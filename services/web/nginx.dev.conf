# Tell Nginx to use the Docker DNS resolver
# We use valid=60s, so that we override the 5 min defualt TTL nginx uses. Wehn using valid=60s Nginx will cache the IP
# addresses it gets from Dockerâ€™s DNS (at 127.0.0.11) for 60 seconds before it re-queries the DNS server.
# https://nginx.org/en/docs/http/ngx_http_core_module.html#resolver
resolver 127.0.0.11 valid=60s;

# Configure service discover as per: https://docs.docker.com/engine/swarm/networking/#configure-service-discovery
# https://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream
upstream backend {
    zone upstream_backend 64k;
    # the monolith prefix is the name of the docker stack
    # py_api is the name of the serivce in this Swarm service stack
    # 8080 is the port the service listens to
    # we use resolve so that if the range of IP, corresponding to the service changes (e.g. more repolcas are spawned),
    # nginx will automtaically modify the upstream configuration without the need of restarting.
    server py-api:8080 resolve;
}


# If there is a http (http requests come from port 80) request coming through, redirect it (301) to use https
server {
    listen 80;
    server_name _;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    # Mime types are just media types. They specify the media in the format i.e `text/plain` or `text/html`
    # giving information about what we should expect to find in the request body
    include mime.types;

    auth_basic "Restricted Access";
    auth_basic_user_file /conf/basic-auth/nginx/.htpasswd;

    # location of the ssh certificates to allow https connections
    ssl_certificate /etc/letsencrypt/live/dev.thehub-aubg.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/dev.thehub-aubg.com/privkey.pem;

    # We check if the URI is a frontend route so that we can serve that content to the client directly.
    location / {
        root /usr/share/nginx/html/;
        include /etc/nginx/mime.types;
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_http_version 1.1;
        proxy_set_header "Connection" "";
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $remote_addr;
        # Here the name of the running service is used to forward the request to the backend
        # You can retrieve the service names by doing `docker service ls`
        proxy_pass https://backend;
    }
}
