from abc import ABC
from dataclasses import dataclass, field
from datetime import datetime
from typing import Annotated, Any, Literal, cast

from bson import ObjectId
from pydantic import BaseModel, Field
from pydantic.json_schema import WithJsonSchema
from pydantic.main import IncEx

from src.database.model.json_serializer import SerializableDbModel

SerializableObjectId = Annotated[ObjectId, WithJsonSchema({"type": "string", "format": "objectid"})]
"""As the original Mongo ObjectID is not json serializable this is needed to represent the ObjectID as a string in API
responses and OpenAPI documentation generated by FastAPI using the Pydantic Models. If we use the default one, the
Swagger page will throw an error because it cannot serialize the standard Mongo ObjectID
https://docs.pydantic.dev/latest/concepts/json_schema/#withjsonschema-annotation"""


# https://stackoverflow.com/questions/51575931/class-inheritance-in-python-3-7-dataclasses ans with 150 up votes
# https://www.trueblade.com/blogs/news/python-3-10-new-dataclass-features
@dataclass(kw_only=True)
class BaseDbModel(SerializableDbModel, ABC):
    id: SerializableObjectId = field(default_factory=ObjectId)
    """We create the ID on demand in order to use the created object as a return type of a function and have all the
    info as type safe attributes"""
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)


class UpdateParams(BaseModel, ABC):
    updated_at: datetime = Field(default_factory=datetime.now)

    # We override BaseModel.model_dump to enforce safe PATCH semantics by default.
    # - exclude_unset=True: prevents accidentally overwriting existing DB fields with None
    #   when a key is omitted in the request body.
    # - exclude_none=False: still allows explicitly provided None values to be persisted
    #   when the API needs to null a field on purpose.
    # For details, see Pydantic v2 serialization docs:
    # https://docs.pydantic.dev/latest/concepts/serialization/#excluding-and-including-fields-based-on-their-value
    #
    # Note: Pydantic type stubs may mark some signatures/returns as Any. We keep an
    # explicit return type of dict[str, Any] here to preserve downstream type clarity.
    def model_dump(
        self,
        *,
        mode: Literal["json", "python"] | str = "python",
        include: IncEx | None = None,
        exclude: IncEx | None = None,
        context: Any | None = None,
        by_alias: bool = False,
        exclude_unset: bool = True,
        exclude_defaults: bool = False,
        exclude_none: bool = False,
        round_trip: bool = False,
        warnings: bool | Literal["none", "warn", "error"] = True,
        serialize_as_any: bool = False,
    ) -> dict[str, Any]:
        return cast(
            dict[str, Any],
            super().model_dump(
                mode=mode,
                include=include,
                exclude=exclude,
                context=context,
                by_alias=by_alias,
                exclude_unset=exclude_unset,
                exclude_defaults=exclude_defaults,
                exclude_none=exclude_none,
                round_trip=round_trip,
                warnings=warnings,
                serialize_as_any=serialize_as_any,
            ),
        )
